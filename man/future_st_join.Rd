% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/future_st_join.R
\name{future_st_join}
\alias{future_st_join}
\alias{future_st_join.sf}
\alias{future_st_filter}
\alias{future_st_filter.sf}
\title{Parallel implementations of \code{sf::st_join} and \code{sf::st_filter}}
\usage{
future_st_join(x, y, join, ...)

\method{future_st_join}{sf}(
  x,
  y,
  join = st_intersects,
  ...,
  suffix = c(".x", ".y"),
  largest = FALSE,
  left = TRUE,
  ncores = parallel::detectCores(),
  nchunks = 1,
  .progress = FALSE
)

future_st_filter(x, y, ...)

\method{future_st_filter}{sf}(
  x,
  y,
  ...,
  .predicate = st_intersects,
  ncores = parallel::detectCores(),
  n_chunks = 1,
  .progress = FALSE
)
}
\arguments{
\item{x}{object of class \code{sf}}

\item{y}{object of class \code{sf}}

\item{join}{geometry predicate function with the same profile
as \link{st_intersects}; see details}

\item{...}{for \code{st_join}: arguments passed on to the \code{join}
function or to \code{st_intersection} when \code{largest} is \code{TRUE};
for \code{st_filter} arguments passed on to the \code{.predicate} function,
e.g. \code{prepared}, or a pattern for \link{st_relate}}

\item{suffix}{length 2 character vector; see \link[base]{merge}}

\item{largest}{logical; if \code{TRUE}, return \code{x} features augmented
with the fields of \code{y} that have the largest overlap with each of the
features of \code{x}; see https://github.com/r-spatial/sf/issues/578}

\item{left}{left logical; if \code{TRUE} return the left join, otherwise
an inner join; see details.
see also \link[dplyr:mutate-joins]{left_join}}

\item{ncores}{Integer many processes do you want to use. Default is all
available cores}

\item{nchunks}{The number of chunks to run on each core. Default is 1.
Can improve or worsen performance depending on dataset size and number of cores}

\item{.progress}{Show progress bar. Only useful when nchunks > 1. default is FALSE}

\item{.predicate}{geometry predicate function with the same profile as \link{st_intersects}; see details}
}
\value{
an object of class \code{sf}, joined based on geometry
}
\description{
Where the first sf object object (x) is split into chunks and joined with /
filtered by the second (y). This will work best when x is large and y is
small. It won't be kind to your machine's memory.
}
\details{
See \link[sf]{st_join} for detais regarding join types.
}
